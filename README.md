# Reacr-w25

*1. В компонент передаются атрибуты description и title . Могу ли я их сложить как на примере, чтобы получить одну строку и вывести в компоненте?* 
```
import React from "react";
import styles from './button.css'

export default class Example extends React.Component {
    render() {
				let {description,title} = this.props
				title += description; //title = title + description
         return (
            <span>{title}</span>
        );
    }
} 
```
вроде как лучше этого не делать, т.к. идет изменение пропса напрямую, что противоречит принципам React 
*2. С помощью какого метода можно отловить изменение `props`?*

С помощью метода shouldComponentUpdate() Он получает такие аргументы, как nextProps и nextState,
которые помогают нам решить, следует ли выполнить повторный рендеринг, выполнив сравнение с текущим значением props.

*3. Оператор расширения часто используется также для клонирования объекта. Подумайте, чем отличаются эти две записи и какую проблему решает здесь оператор расширения:*

    ```
    const initialObj = { title:'Hello', text:'World' }
    //№1
    const firstObj = initialObj
    //№2
    const secondObj = {...initialObj}
    ```
В первом случае объект просто клонируется, а во втором с помощью оператора расширения можно добавить дополнительные свойства клонируемому объекту

*4. В каком из методов жизненного цикла лучше всего использовать методы вызова API и обращения к веб-хранилищам,
если они должны быть вызваны всего один раз при загрузке страницы?*

Метод componentDidMount()

*5. С помощью какого метода можно отловить и отрисовать для пользователя возникшую в компоненте ошибку?*

componentDidCatch(error, info)

*6. Какой код обычно пишут в конструкторе? Для каких задач он используется?*
```
constructor(props) {
   super(props);
   this.state = {
```
в конструкторе объявляются все свойства, это единственное место где вы можете изменять/устанавливать состояние (state), напрямую перезаписывая поле this.state

*7. Что делает функция `render`()? Что может ее вызвать?*

Перерисовывает компонент. Перерисовка родительского компонента, перерисовка в связи с внутренними изменениями,
перерисовка в связи с вызовом this.forceUpdate, перерисовка в связи с перехватом ошибки

*8. Что нужно изменить в коде из урока (видео), чтобы начальные параметры у компонента приходили из пропсов,
но если пропсы вообще не заданы, начальные значения были инициализированы нулями?*

Не уверена. Но если пропсы не заданы, то то можно их внести в функцию рендер в качестве динамически изменяемых переменных типа
```
 render() {
    const { minutes } = this.props;
    const { seconds } = this.props;
   return ( <div> .... </div>)}
```
*9. Можно ли несколько раз использовать хук useEffect внутри одного компонента?*

Можно

*10. Можно ли не передавать второй аргумент в хук useEffect, что  тогда произойдет?*

Можно, но если передадим второй аргумент в виде пустого массива зависимостей,
функция обратного вызова будет запущена только один раз после первой визуализации

*11. Что означает возвращение функции в теле  хука `useEffect`?*

Используя этот хук, вы сообщаете React, что ваш компонент должен что-то сделать после рендеринга.
React запомнит переданную вами функцию ( «эффект») и вызовет ее позже после выполнения обновлений DOM.
Если ваш эффект возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект.

*12. Будут ли перерисованы дочерние элементы компонента при вызове метода `forceUpdate`()?*

Да
